name: 'üì¶ Subflow - Release Management'

on:
  workflow_call:
    inputs:
      version:
        description: 'Version for the release'
        required: true
        type: string
      is-prerelease:
        description: 'Whether this is a pre-release'
        required: false
        type: string
        default: 'false'
      release-notes:
        description: 'Release notes content'
        required: false
        type: string
        default: ''
      artifacts-path:
        description: 'Path to artifacts to upload'
        required: false
        type: string
        default: 'artifacts'
      checkout-ref:
        description: 'Git reference to checkout'
        required: false
        type: string
        default: ''
      target-branch:
        description: 'Target branch for generating release notes (main, dev, etc.)'
        required: false
        type: string
        default: 'main'
      commit-sha:
        description: 'Specific commit SHA to tag (optional, uses HEAD if not provided)'
        required: false
        type: string
        default: ''
    secrets:
      github-token:
        description: 'GitHub token for creating release'
        required: true
    outputs:
      release-url:
        description: 'URL of the created release'
        value: ${{ jobs.release-management.outputs.release-url }}
      release-id:
        description: 'ID of the created release'
        value: ${{ jobs.release-management.outputs.release-id }}

jobs:
  release-management:
    name: Release Management
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    outputs:
      release-url: ${{ steps.create-release.outputs.html_url }}
      release-id: ${{ steps.create-release.outputs.id }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v5
      with:
        ref: ${{ inputs.checkout-ref || github.ref }}
        fetch-depth: 0  # Fetch full history including tags

    - name: Setup GitHub CLI
      run: |
        echo "${{ secrets.github-token }}" | gh auth login --with-token
      shell: bash

    - name: Download build artifacts (includes installers)
      uses: actions/download-artifact@v5
      with:
        name: build-artifacts
        path: ${{ inputs.artifacts-path }}/

    - name: Generate custom release notes
      id: generate-notes
      shell: pwsh
      run: |
        Write-Host "=== Generating Custom Release Notes ==="-ForegroundColor Cyan

        $targetBranch = "${{ inputs.target-branch }}"
        $version = "${{ inputs.version }}"
        $isPrerelease = "${{ inputs.is-prerelease }}" -eq "true"

        Write-Host "Target branch: $targetBranch" -ForegroundColor Yellow
        Write-Host "Version: $version" -ForegroundColor Yellow
        Write-Host "Is prerelease: $isPrerelease" -ForegroundColor Yellow

        # Get the latest release tag - fetch tags first
        Write-Host "Fetching tags..." -ForegroundColor Gray
        git fetch --tags --quiet 2>$null

        # Get reference tag based on release type
        if ($isPrerelease -and $targetBranch -eq "dev") {
          # For nightly builds, compare with previous nightly tags
          $latestTag = git tag -l --sort=-version:refname | Where-Object { $_ -match '\-Nightly$' } | Select-Object -First 1
        } else {
          # For stable releases, compare with previous stable releases
          $latestTag = git tag -l --sort=-version:refname | Where-Object { $_ -notmatch '\-Nightly$' } | Select-Object -First 1
        }
        if ([string]::IsNullOrEmpty($latestTag)) {
          # Fallback: try without version sort with appropriate filtering
          if ($isPrerelease -and $targetBranch -eq "dev") {
            $latestTag = git tag --sort=-creatordate | Where-Object { $_ -match '\-Nightly$' } | Select-Object -First 1
          } else {
            $latestTag = git tag --sort=-creatordate | Where-Object { $_ -notmatch '\-Nightly$' } | Select-Object -First 1
          }
        }
        # If no tag found with filtering, that's OK - means it's the first nightly/release
        if ([string]::IsNullOrEmpty($latestTag)) {
          Write-Host "No previous tags found with the current filter (nightly/stable)" -ForegroundColor Gray
        }

        Write-Host "Latest tag: '$latestTag'" -ForegroundColor Yellow

        $releaseNotes = ""

        if ($isPrerelease -and $targetBranch -eq "dev") {
          Write-Host "Generating nightly release notes from dev branch" -ForegroundColor Green

          # Get merged PRs since last tag on dev branch
          if ([string]::IsNullOrEmpty($latestTag)) {
            $mergedPRs = git log --merges --grep="Merge pull request" --pretty=format:"%h %s" $targetBranch 2>$null
          } else {
            $mergedPRs = git log --merges --grep="Merge pull request" --pretty=format:"%h %s" "$latestTag..$targetBranch" 2>$null
          }

          if (![string]::IsNullOrEmpty($mergedPRs)) {
            $releaseNotes += "## üöÄ Changes in this nightly build`n`n"
            $releaseNotes += "This nightly build includes the following merged pull requests since the last release:`n`n"

            # Collect unique PR numbers
            $prNumbers = @()
            $mergedPRs -split "`n" | ForEach-Object {
              if ($_ -match "Merge pull request #(\d+)") {
                $prNumbers += $matches[1]
              }
            }

            # Remove duplicates and sort in ascending numeric order
            $prNumbers = $prNumbers | Sort-Object { [int]$_ } -Unique

            # Get PR details for each PR number
            $prNumbers | ForEach-Object {
              $prNumber = $_
              try {
                Write-Host "Fetching details for PR #$prNumber..." -ForegroundColor Gray

                # First try with gh CLI
                $prInfo = gh pr view $prNumber --json title,author --repo "${{ github.repository }}" 2>$null | ConvertFrom-Json
                if ($prInfo -and $prInfo.title) {
                  $title = $prInfo.title
                  $author = $prInfo.author.login
                  $releaseNotes += "- **#$prNumber**: $title by @$author`n"
                } else {
                  # Fallback: try to get basic info from git log
                  Write-Host "Fallback: Using git log for PR #$prNumber..." -ForegroundColor Gray
                  $commitInfo = git log --grep="Merge pull request #$prNumber" --pretty=format:"%s" -1 2>$null
                  if ($commitInfo -and $commitInfo -match "Merge pull request #$prNumber from .*/(.+)") {
                    $branchName = $matches[1]
                    $releaseNotes += "- **#$prNumber**: $branchName`n"
                  } else {
                    $releaseNotes += "- **#$prNumber**: _PR details not available_`n"
                  }
                }
              } catch {
                Write-Host "Warning: Could not fetch details for PR #$prNumber - Error: $($_.Exception.Message)" -ForegroundColor Yellow
                # Try git log fallback
                $commitInfo = git log --grep="Merge pull request #$prNumber" --pretty=format:"%s" -1 2>$null
                if ($commitInfo -and $commitInfo -match "Merge pull request #$prNumber from .*/(.+)") {
                  $branchName = $matches[1]
                  $releaseNotes += "- **#$prNumber**: $branchName`n"
                } else {
                  $releaseNotes += "- **#$prNumber**: _PR details not available_`n"
                }
              }
            }

            $releaseNotes += "`n‚ö†Ô∏è **Warning**: This is an automated nightly build and may contain unstable features.`n`n"
          } else {
            $releaseNotes += "## üöÄ Nightly Build`n`n"
            $releaseNotes += "This nightly build was generated automatically.`n`n"
            $releaseNotes += "‚ö†Ô∏è **Warning**: This build may contain unstable features and is intended for testing purposes only.`n`n"
          }
        } else {
          Write-Host "Using default GitHub release notes generation" -ForegroundColor Green
          $releaseNotes = "<!-- GitHub will generate release notes automatically -->"
        }

        # Output the generated notes
        $releaseNotes | Out-File -FilePath "custom-release-notes.md" -Encoding UTF8

        # Use proper multiline output format for GitHub Actions
        Add-Content -Path $env:GITHUB_OUTPUT -Value "custom_notes<<EOF"
        Add-Content -Path $env:GITHUB_OUTPUT -Value $releaseNotes
        Add-Content -Path $env:GITHUB_OUTPUT -Value "EOF"

        Write-Host "Custom release notes generated" -ForegroundColor Green
        exit 0

    - name: Calculate file hashes and generate body
      id: calculate-hashes
      shell: pwsh
      run: |
        Write-Host "=== Calculating File Hashes and Generating Body ===" -ForegroundColor Cyan

        $version = "${{ inputs.version }}"
        $repository = "${{ github.repository }}"

        # Start building the table
        $tableRows = @()

        # Process MSI files
        $installersPath = "${{ inputs.artifacts-path }}/installers"
        if (Test-Path $installersPath) {
          Get-ChildItem -Path $installersPath -Filter "*.msi" | Sort-Object Name | ForEach-Object {
            $hash = (Get-FileHash $_.FullName -Algorithm SHA256).Hash
            Write-Host "MSI: $($_.Name) = $hash" -ForegroundColor Yellow

            $fileName = $_.Name
            $downloadUrl = "https://github.com/$repository/releases/download/v$version/$fileName"
            $badgeUrl = "https://img.shields.io/github/downloads/$repository/v$version/$fileName"

            $tableRows += "|[$fileName]($downloadUrl)|``$hash``|<picture>![$fileName]($badgeUrl`?style=flat-square&label=&color=blue)</picture>|"
          }
        }


        # Create the complete table
        $filesTable = @"
        ## Files
        |Files|Hash (SHA256)|Downloads|
        |---|---|---|
        $($tableRows -join "`n")
        "@

        # Save the table to output
        $filesTable | Out-File -FilePath "files-table.md" -Encoding UTF8

        # Use proper multiline output format for GitHub Actions
        Add-Content -Path $env:GITHUB_OUTPUT -Value "files_table<<EOF"
        Add-Content -Path $env:GITHUB_OUTPUT -Value $filesTable
        Add-Content -Path $env:GITHUB_OUTPUT -Value "EOF"

        Write-Host "File hashes calculated and table generated" -ForegroundColor Green

    - name: Collect artifacts for upload
      id: collect-artifacts
      shell: pwsh
      run: |
        Write-Host "=== Collecting Artifacts ===" -ForegroundColor Cyan

        $artifacts = @()


        # Collect MSI files
        $installersPath = "${{ inputs.artifacts-path }}/installers"
        if (Test-Path $installersPath) {
          Get-ChildItem -Path $installersPath -Filter "*.msi" | ForEach-Object {
            $artifacts += $_.FullName
            Write-Host "Added MSI: $($_.Name)" -ForegroundColor Yellow
          }
        }

        $artifactsList = $artifacts -join ","
        echo "artifacts_list=$artifactsList" >> $env:GITHUB_OUTPUT
        Write-Host "Artifacts collected: $($artifacts.Count)" -ForegroundColor Green

    - name: Determine commit SHA
      id: get-commit
      shell: bash
      run: |
        if [ -n "${{ inputs.commit-sha }}" ]; then
          COMMIT_SHA="${{ inputs.commit-sha }}"
          echo "Using provided commit SHA: $COMMIT_SHA"
        else
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "Using current HEAD commit: $COMMIT_SHA"
        fi
        echo "commit-sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
        echo "Tagging commit: $COMMIT_SHA"

    - name: Create GitHub Release
      id: create-release
      uses: ncipollo/release-action@v1.20.0
      with:
        tag: v${{ inputs.version }}
        name: Bucket ${{ inputs.version }}
        commit: ${{ steps.get-commit.outputs.commit-sha }}
        prerelease: ${{ inputs.is-prerelease }}
        generateReleaseNotes: ${{ inputs.target-branch == 'main' }}
        artifacts: ${{ steps.collect-artifacts.outputs.artifacts_list }}
        token: ${{ secrets.github-token }}
        body: |
          ${{ inputs.target-branch == 'dev' && inputs.is-prerelease == 'true' && steps.generate-notes.outputs.custom_notes || inputs.release-notes }}${{ steps.calculate-hashes.outputs.files_table }}


    - name: Generate job summary
      shell: pwsh
      run: |
        Write-Host "=== Generating Job Summary ===" -ForegroundColor Cyan

        $summary = @"
        # üöÄ Release Published: Bucket ${{ inputs.version }}

        ## üì¶ Release Information
        - **Version**: ``${{ inputs.version }}``
        - **Type**: $(if ("${{ inputs.is-prerelease }}" -eq "true") { "Pre-release (Nightly)" } else { "Stable Release" })
        - **Release URL**: https://github.com/${{ github.repository }}/releases/tag/v${{ inputs.version }}

        ## üìã Artifacts

        ### MSI Installers (Available for Download)
        "@


        $installersPath = "${{ inputs.artifacts-path }}/installers"
        if (Test-Path $installersPath) {
          Get-ChildItem -Path $installersPath -Filter "*.msi" | ForEach-Object {
            $summary += "`n- ``$($_.Name)`` ($('{0:N2} MB' -f ($_.Length / 1MB)))"
          }
        }

        $summary += @"


        ## ‚úÖ Release Complete
        All artifacts have been successfully uploaded to the GitHub release.
        "@

        $summary | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append
        Write-Host "Job summary generated" -ForegroundColor Green
