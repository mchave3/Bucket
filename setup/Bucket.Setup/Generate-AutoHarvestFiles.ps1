# Script pour g√©n√©rer automatiquement AutoHarvestFiles.wxs avec tous les fichiers publi√©s
param(
    [string]$PublishPath = "..\..\src\Bucket.App\bin\x64\Release\net9.0-windows10.0.26100\win-x64\publish",
    [string]$OutputFile = "AutoHarvestFiles.wxs"
)

Write-Host "üöÄ G√©n√©ration automatique de $OutputFile" -ForegroundColor Green
Write-Host "üìÅ R√©pertoire source: $PublishPath" -ForegroundColor Cyan

# R√©soudre le chemin absolu
$PublishPathResolved = Resolve-Path $PublishPath
Write-Host "üìÅ Chemin r√©solu: $PublishPathResolved" -ForegroundColor Gray

# V√©rifier que le r√©pertoire existe
if (-not (Test-Path $PublishPathResolved)) {
    Write-Error "‚ùå R√©pertoire de publication non trouv√©: $PublishPathResolved"
    exit 1
}

# Collecter tous les fichiers (y compris les fichiers de localisation)
$files = Get-ChildItem -Path $PublishPathResolved -Recurse -File
Write-Host "üìä Nombre de fichiers trouv√©s: $($files.Count)" -ForegroundColor Yellow

# Analyser tous les r√©pertoires n√©cessaires
$directories = @{}
foreach ($file in $files) {
    $relativeDir = [System.IO.Path]::GetDirectoryName($file.FullName.Replace($PublishPathResolved.Path, "").TrimStart('\'))
    if ($relativeDir -and $relativeDir -ne "") {
        $directories[$relativeDir] = $true
    }
}

# D√©but du fichier WiX avec structure de r√©pertoires
$wixContent = @"
<Wix xmlns="http://wixtoolset.org/schemas/v4/wxs">
  <?include Variables.wxi ?>
  <Fragment>
    <!-- Directory Structure -->
    <DirectoryRef Id="INSTALLFOLDER">
"@

# Cr√©er la structure de r√©pertoires de mani√®re hi√©rarchique
$dirIds = @{"" = "INSTALLFOLDER"}  # R√©pertoire racine
$sortedDirs = $directories.Keys | Sort-Object

# Premi√®re passe : cr√©er tous les IDs de r√©pertoires
foreach ($dir in $sortedDirs) {
    $pathParts = $dir.Split('\')
    $currentPath = ""

    for ($i = 0; $i -lt $pathParts.Length; $i++) {
        if ($i -eq 0) {
            $currentPath = $pathParts[$i]
        } else {
            $currentPath = $currentPath + "\" + $pathParts[$i]
        }

        if (-not $dirIds.ContainsKey($currentPath)) {
            $dirId = "Dir_" + ($currentPath -replace '[\\\/\-\.\s]', '_').Replace('___', '_').Replace('__', '_')
            $dirIds[$currentPath] = $dirId
        }
    }
}

# Deuxi√®me passe : cr√©er tous les r√©pertoires de mani√®re simple
# Cr√©er d'abord tous les r√©pertoires parents n√©cessaires
$allPaths = @()
foreach ($dir in $sortedDirs) {
    $pathParts = $dir.Split('\')
    $currentPath = ""
    for ($i = 0; $i -lt $pathParts.Length; $i++) {
        if ($i -eq 0) {
            $currentPath = $pathParts[$i]
        } else {
            $currentPath = $currentPath + "\" + $pathParts[$i]
        }
        if ($allPaths -notcontains $currentPath) {
            $allPaths += $currentPath
        }
    }
}

# Trier par profondeur (nombre de \ dans le chemin) en filtrant les valeurs nulles
$allPaths = $allPaths | Where-Object { $_ -ne $null -and $_ -ne "" } | Sort-Object { $_.Split('\').Length }, $_

# Cr√©er tous les r√©pertoires avec leur structure hi√©rarchique
$openTags = @()
$currentDepth = 0

foreach ($path in $allPaths) {
    $pathParts = $path.Split('\')
    $depth = $pathParts.Length
    $dirName = $pathParts[-1]
    $dirId = "Dir_" + ($path -replace '[\\\/\-\.\s]', '_').Replace('___', '_').Replace('__', '_')
    $dirIds[$path] = $dirId

    Write-Host "üìÅ Traitement: $path (depth=$depth, currentDepth=$currentDepth)" -ForegroundColor Cyan

    # Fermer les tags si on remonte dans l'arborescence
    $loopCount = 0
    while ($currentDepth -ge $depth) {
        $loopCount++
        if ($loopCount -gt 100) {
            Write-Host "‚ùå ERREUR: Boucle infinie d√©tect√©e! currentDepth=$currentDepth, depth=$depth" -ForegroundColor Red
            Write-Host "   Path: $path" -ForegroundColor Red
            Write-Host "   OpenTags: $($openTags -join ', ')" -ForegroundColor Red
            break
        }

        Write-Host "  üîΩ Fermeture niveau $currentDepth" -ForegroundColor Yellow
        $wixContent += ("  " * ($currentDepth + 1)) + "</Directory>`n"
        if ($openTags.Length -gt 0) {
            $openTags = $openTags[0..($openTags.Length-2)]
        }
        $currentDepth--
    }

    # Ouvrir le nouveau r√©pertoire
    Write-Host "  üîº Ouverture niveau $depth : $dirName" -ForegroundColor Green
    $indent = "  " * ($depth + 1)
    $wixContent += "$indent<Directory Id=`"$dirId`" Name=`"$dirName`">`n"
    $openTags += $dirId
    $currentDepth = $depth
}

# Fermer tous les tags restants
Write-Host "üîö Fermeture finale: $($openTags.Length) tags ouverts, currentDepth=$currentDepth" -ForegroundColor Magenta
while ($openTags.Length -gt 0 -and $currentDepth -gt 0) {
    Write-Host "  üîΩ Fermeture finale niveau $currentDepth" -ForegroundColor Yellow
    $indent = "  " * ($currentDepth + 1)
    $wixContent += "$indent</Directory>`n"
    if ($openTags.Length -gt 0) {
        $openTags = $openTags[0..($openTags.Length-2)]
    }
    $currentDepth--
}

$wixContent += @"
    </DirectoryRef>

    <!-- Auto-generated components by directory -->
"@

# G√©n√©rer un GUID unique pour chaque composant
function New-Guid {
    [System.Guid]::NewGuid().ToString().ToUpper()
}

# Cr√©er des ComponentGroups pour chaque r√©pertoire
$componentsByDir = @{}
foreach ($file in $files) {
    $relativeFilePath = $file.FullName.Replace($PublishPathResolved.Path, "").TrimStart('\')
    $relativeDir = [System.IO.Path]::GetDirectoryName($relativeFilePath)

    if (-not $componentsByDir.ContainsKey($relativeDir)) {
        $componentsByDir[$relativeDir] = @()
    }
    $componentsByDir[$relativeDir] += $file
}

# G√©n√©rer les composants pour chaque r√©pertoire
$componentIndex = 1
$isFirstGroup = $true
foreach ($dir in $componentsByDir.Keys | Sort-Object) {
    $dirId = if ($dir -eq "") { "INSTALLFOLDER" } else { $dirIds[$dir] }

    if (-not $isFirstGroup) {
        $wixContent += "    </ComponentGroup>`n`n"
    }
    $isFirstGroup = $false

    $dirDisplayName = if ($dir -eq "") { "Root" } else { $dir }
    $groupId = "Files_" + ($dirDisplayName -replace '[\\\/\-\.\s]', '_').Replace('___', '_').Replace('__', '_') + "_Group"
    $wixContent += "    <!-- Components for directory: $dirDisplayName -->`n"
    $wixContent += "    <ComponentGroup Id=`"$groupId`" Directory=`"$dirId`">`n"

    foreach ($file in $componentsByDir[$dir]) {
        $relativeFilePath = $file.FullName.Replace($PublishPathResolved.Path, "").TrimStart('\')
        $fileName = $file.Name

        # Cr√©er un nom de composant valide (limit√© √† 72 caract√®res)
        $baseName = "File_" + ($fileName -replace '[\\\/\-\.\s]', '_').Replace('___', '_').Replace('__', '_')
        if ($baseName.Length -gt 50) {
            $baseName = $baseName.Substring(0, 50)
        }
        $componentName = "${baseName}_$componentIndex"
        $componentGuid = "{" + (New-Guid) + "}"

        $fileId = $componentName
        $sourcePath = "`$(var.PublishOutputPath)$relativeFilePath"

        $wixContent += "      <!-- File: $fileName -->`n"
        $wixContent += "      <Component Id=`"$componentName`" Guid=`"$componentGuid`">`n"
        $wixContent += "        <File Id=`"$fileId`" Source=`"$sourcePath`" KeyPath=`"yes`" />`n"
        $wixContent += "      </Component>`n`n"

        $componentIndex++
    }
}

# Cr√©er le ComponentGroup principal qui r√©f√©rence tous les autres
$wixContent += "    </ComponentGroup>`n`n"
$wixContent += "    <!-- Main ComponentGroup that references all directory groups -->`n"
$wixContent += "    <ComponentGroup Id=`"AutoHarvestedFiles`">`n"

foreach ($dir in $componentsByDir.Keys | Sort-Object) {
    $dirDisplayName = if ($dir -eq "") { "Root" } else { $dir }
    $groupId = "Files_" + ($dirDisplayName -replace '[\\\/\-\.\s]', '_').Replace('___', '_').Replace('__', '_') + "_Group"
    $wixContent += "      <ComponentGroupRef Id=`"$groupId`" />`n"
}

$wixContent += @"
    </ComponentGroup>
  </Fragment>
</Wix>
"@

# √âcrire le fichier
Set-Content -Path $OutputFile -Value $wixContent -Encoding UTF8
Write-Host "‚úÖ Fichier g√©n√©r√©: $OutputFile" -ForegroundColor Green
Write-Host "üìä Composants cr√©√©s: $($componentIndex - 1)" -ForegroundColor Cyan

# V√©rifier la taille du fichier g√©n√©r√©
$fileInfo = Get-Item $OutputFile
Write-Host "üìÑ Taille du fichier: $([math]::Round($fileInfo.Length / 1KB, 2)) KB" -ForegroundColor Gray
